# Story 011.4: Establish Fragment-Based Architecture

**Story ID:** 011.4  
**Epic:** 011 - Hybrid Prompt Architecture Migration  
**Created:** 2025-10-05  
**Status:** Ready  
**Priority:** High  
**Effort:** 2-3 days  
**Confidence:** 95%

---

## Story

As a developer, I need a fragment-based hybrid architecture established so that I can migrate both static and dynamic prompts in a consistent, maintainable way.

---

## Context

Story 011.3 identified that our "Big Bang" migration approach failed because prompts aren't uniform:
- Some prompts are fully static (easy to centralize in YAML)
- Some prompts need runtime data injection (keywords, focus areas)

The Fragment-Based Hybrid Architecture solves this by:
- Storing static prompt fragments in YAML
- Composing final prompts in Python with runtime data
- Using Python's native `.format()` (no new dependencies)

This story establishes the pattern with proof-of-concept implementation.

---

## Acceptance Criteria

- [ ] `config/prompts/fragments.yaml` file created with initial structure
- [ ] `PromptLibrary.get_fragment()` method implemented and tested
- [ ] One simple file migrated as proof-of-concept (deduplication.py or summarizer.py)
- [ ] Pattern documented in `config/prompts/README.md`
- [ ] Fragment composition test added
- [ ] Migrated file produces same output as baseline

---

## Tasks

### Task 1: Create fragments.yaml Structure
**Subtasks:**
- [ ] Create `config/prompts/fragments.yaml` file
- [ ] Add `common` section with reusable fragments:
  - [ ] `classifier_header` - Generic classifier introduction
  - [ ] `output_format` - Standard JSON response format
  - [ ] `swiss_context` - Swiss business/financial context
- [ ] Add `filter` section (for future Story 011.5)
- [ ] Add `analysis` section (for future Story 011.6)
- [ ] Validate YAML syntax

**Example Structure:**
```yaml
common:
  classifier_header: "You are an expert news classifier for Swiss business and financial news."
  output_format: "Return strict JSON with is_match, confidence, reason fields."
  swiss_context: "Focus on Swiss business, financial, and regulatory context."
  
filter:
  # Will be populated in Story 011.5
  
analysis:
  # Will be populated in Story 011.6
```

### Task 2: Enhance PromptLibrary with get_fragment()
**Subtasks:**
- [ ] Add `get_fragment(category: str, fragment_name: str) -> str` method
- [ ] Implement lazy loading for fragments (cache after first load)
- [ ] Add proper error handling (KeyError with helpful messages)
- [ ] Update class docstring

**Implementation Spec:**
```python
def get_fragment(self, category: str, fragment_name: str) -> str:
    """Get reusable prompt fragment.
    
    Args:
        category: Fragment category (e.g., 'common', 'filter')
        fragment_name: Specific fragment name
        
    Returns:
        Fragment text
        
    Raises:
        KeyError: If category or fragment not found
    """
    if not hasattr(self, '_fragments'):
        fragments_path = config_path('prompts', 'fragments.yaml')
        with safe_open(fragments_path, 'r', encoding='utf-8') as f:
            self._fragments = yaml.safe_load(f)
    
    if category not in self._fragments:
        available = ', '.join(self._fragments.keys())
        raise KeyError(
            f"Fragment category '{category}' not found. "
            f"Available categories: {available}"
        )
    
    if fragment_name not in self._fragments[category]:
        available = ', '.join(self._fragments[category].keys())
        raise KeyError(
            f"Fragment '{fragment_name}' not found in category '{category}'. "
            f"Available fragments: {available}"
        )
    
    return self._fragments[category][fragment_name]
```

### Task 3: Choose and Migrate Proof-of-Concept File
**Decision:** Pick the simpler file between deduplication.py or summarizer.py

**For deduplication.py:**
- [ ] Read current prompt structure
- [ ] Identify static vs dynamic parts
- [ ] Extract static parts to fragments.yaml
- [ ] Refactor code to use get_fragment() + format()
- [ ] Test that deduplication still works correctly

**For summarizer.py (alternative):**
- [ ] Read current prompt structure
- [ ] Identify static vs dynamic parts
- [ ] Extract static parts to fragments.yaml
- [ ] Refactor code to use get_fragment() + format()
- [ ] Test that summarization still works correctly

### Task 4: Create Fragment Composition Tests
**Subtasks:**
- [ ] Create `tests/test_prompt_fragments.py`
- [ ] Test: get_fragment() returns correct text
- [ ] Test: get_fragment() with invalid category raises KeyError
- [ ] Test: get_fragment() with invalid fragment raises KeyError
- [ ] Test: Fragment composition with format() works
- [ ] Test: Lazy loading (fragments cached after first load)

**Test Template:**
```python
def test_fragment_retrieval():
    lib = PromptLibrary()
    header = lib.get_fragment('common', 'classifier_header')
    assert 'expert news classifier' in header.lower()

def test_fragment_composition():
    lib = PromptLibrary()
    header = lib.get_fragment('common', 'classifier_header')
    output = lib.get_fragment('common', 'output_format')
    
    prompt = f"{header}\n\n{output}"
    assert 'classifier' in prompt
    assert 'JSON' in prompt
```

### Task 5: Document the Pattern
**Subtasks:**
- [ ] Update `config/prompts/README.md` with:
  - [ ] Fragment-based architecture explanation
  - [ ] When to use fragments vs full prompts
  - [ ] Example of fragment composition
  - [ ] Best practices
- [ ] Add code comments in PromptLibrary.get_fragment()
- [ ] Document fragment naming conventions

**Documentation Template:**
```markdown
## Fragment-Based Architecture

### When to Use Fragments
- **Use fragments** for: Reusable prompt components, static text
- **Use full prompts** for: File-specific prompts with no reuse
- **Use hybrid** for: Prompts needing runtime data injection

### Pattern Example
```python
# Get reusable fragments
header = prompt_lib.get_fragment('common', 'classifier_header')
output_format = prompt_lib.get_fragment('common', 'output_format')

# Build dynamic content
dynamic_data = f"Keywords: {', '.join(keywords)}"

# Compose final prompt
prompt = f"{header}\n\n{dynamic_data}\n\n{output_format}"
```

### Best Practices
1. Keep fragments atomic and focused
2. Use descriptive fragment names
3. Document what data each fragment expects
4. Test fragment composition
```

### Task 6: Baseline Validation
**Subtasks:**
- [ ] Run pipeline with migrated file
- [ ] Compare output to baseline_output.md
- [ ] Verify no behavior changes
- [ ] Document any differences (should be none)
- [ ] Update migration_progress.md

---

## Dev Notes

### Files to Modify
1. **news_pipeline/prompt_library.py** - Add get_fragment() method
2. **config/prompts/fragments.yaml** - Create new file
3. **config/prompts/README.md** - Add documentation
4. **tests/test_prompt_fragments.py** - Create new test file
5. **[Proof-of-concept file]** - Either deduplication.py or summarizer.py

### Testing Strategy
1. **Unit tests:** Fragment retrieval and composition
2. **Integration test:** Migrated file produces same output
3. **Baseline comparison:** No behavior regression

### Baseline Files Available
- `baseline.db` - Database snapshot
- `baseline_output.md` - Pipeline output reference
- `baseline_timestamp.txt` - Baseline metadata

---

## Definition of Done

- [ ] All tasks completed
- [ ] All subtasks checked off
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Code reviewed (self-review or peer)
- [ ] Baseline validation confirms no behavior changes
- [ ] Pattern ready for use in Stories 011.5 and 011.6

---

## References

- **Epic:** `docs/stories/epic-011-hybrid-prompt-migration.md`
- **Analysis:** `docs/stories/011.3-elicitation-findings.md`
- **Summary:** `docs/stories/011.3-elicitation-summary.md`
- **Previous:** `docs/stories/011.3.big-bang-migration.md`

---

**Story Created:** 2025-10-05  
**Created By:** Bob (Scrum Master) üèÉ  
**Ready for:** Development
